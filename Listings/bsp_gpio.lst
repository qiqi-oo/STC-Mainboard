C51 COMPILER V9.60.0.0   BSP_GPIO                                                          09/20/2025 15:17:34 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE BSP_GPIO
OBJECT MODULE PLACED IN .\Objects\bsp_gpio.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Bsp\bsp_gpio.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\bsp_gpio.lst) TABS(2) OBJECT(.\Objects\bsp_gpio.obj)

line level    source

   1          
   2          #include  "./User/includes.h"
   3          #include  <stdio.h>
   4          #include  <string.h>
   5          
   6          #ifdef  STC15W4K48S4  
              xdata PengGanSignalTypeDef  pgxd[4];//Á¢∞ÊùÜÊ∂àÊäñ
              #endif
   9          //========================================================================
  10          // ÂáΩÊï∞: void BSP_GPIO_Init(void)
  11          // ÊèèËø∞: ÂàùÂßãÂåñ‰∏ªÊùøIOÂè£.ÂÖ®ÈÉ®ÂàùÂßãÂåñ‰∏∫Ôºö‰∏äÊãâÂáÜÂèåÂêëÂè£
  12          // ÁâàÊú¨: V1.0, 2022-10-17
  13          //========================================================================
  14          void BSP_GPIO_Init(void)
  15          {
  16   1        GPIO_InitTypeDef  GPIO_InitStructure;       //ÁªìÊûÑÂÆö‰πâ
  17   1        
  18   1        GPIO_InitStructure.Pin  = GPIO_Pin_All;     //ÊåáÂÆöË¶ÅÂàùÂßãÂåñÁöÑIO, GPIO_Pin_0 ~ GPIO_Pin_7, ÊàñÊìç‰Ωú
  19   1        GPIO_InitStructure.Mode = GPIO_PullUp;      //ÊåáÂÆöIOÁöÑËæìÂÖ•ÊàñËæìÂá∫ÊñπÂºè,GPIO_PullUp,GPIO_HighZ,GPIO_O
             -UT_OD,GPIO_OUT_PP
  20   1        
  21   1        GPIO_Inilize(GPIO_P0,&GPIO_InitStructure);  //ÂàùÂßãÂåñGPIO_P0
  22   1        GPIO_Inilize(GPIO_P1,&GPIO_InitStructure);  //ÂàùÂßãÂåñGPIO_P1
  23   1        GPIO_Inilize(GPIO_P2,&GPIO_InitStructure);  //ÂàùÂßãÂåñGPIO_P2
  24   1        GPIO_Inilize(GPIO_P3,&GPIO_InitStructure);  //ÂàùÂßãÂåñGPIO_P3
  25   1        GPIO_Inilize(GPIO_P4,&GPIO_InitStructure);  //ÂàùÂßãÂåñGPIO_P4
  26   1        
  27   1      }
  28          //========================================================================
  29          // ÂáΩÊï∞: void BSP_Zhuansu_Init(void)
  30          // ÊèèËø∞: ÂàùÂßãÂåñÂÆöÊó∂Âô®0‰∏∫ËÆ°Êï∞Ê®°ÂºèÔºåÂØπËΩ¨ÈÄüËÑâÂÜ≤ËÆ°Êï∞
  31          // ÁâàÊú¨: V1.0, 2022-10-17
  32          //========================================================================
  33          void BSP_ZhuansuCount_Init(void)
  34          {
  35   1          TMOD |= 0x05; //ËÆæÁΩÆÂÆöÊó∂Âô®0‰∏∫ËÆ°Êï∞Âô®Ê®°Âºè//ÂØπËΩ¨ÈÄüËÑâÂÜ≤ËÆ°Êï∞
  36   1          TH0=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
  37   1          TL0=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
  38   1          TR0=1;        //ËÆ°Êï∞Âô®0ÂºÄÂßãËÆ°Êï∞
  39   1      }
  40          //========================================================================
  41          // ÂáΩÊï∞: void BSP_LichengCount_Init(void)
  42          // ÊèèËø∞: ÂàùÂßãÂåñÂÆöÊó∂Âô®‰∏∫ËÆ°Êï∞Ê®°ÂºèÔºåÂØπËΩ¨ÈÄüËÑâÂÜ≤ËÆ°Êï∞
  43          // ÁâàÊú¨: V1.0, 2023-5-25
  44          //========================================================================
  45          void BSP_LichengCount_Init(void)
  46          {
  47   1      
  48   1          switch(pFlash->lc.pin)
  49   1          {
  50   2            case  LC_T0:                
  51   2                          TMOD |= 0x05; //ËÆæÁΩÆÂÆöÊó∂Âô®0‰∏∫ËÆ°Êï∞Âô®Ê®°Âºè
  52   2                          TH0=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
  53   2                          TL0=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
C51 COMPILER V9.60.0.0   BSP_GPIO                                                          09/20/2025 15:17:34 PAGE 2   

  54   2                          TR0=1;        //ËÆ°Êï∞Âô®0ÂºÄÂßãËÆ°Êï∞
  55   2                          break;
  56   2            case  LC_T1:                
  57   2                          TMOD |= 0x50; //‰ΩøÁî®ËÆ°Êï∞Âô®T1‰∏∫ËÆ°Êï∞Âô®Ê®°Âºè
  58   2                          TH1=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
  59   2                          TL1=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
  60   2                          TR1=1;        //ËÆ°Êï∞Âô®1ÂºÄÂßãËÆ°Êï∞
  61   2                          break;
  62   2          
  63   2      #ifdef  STC15W4K48S4
                    case  LC_T2:                //‰ΩøÁî®ËÆ°Êï∞Âô®T2
                                  AUXR |= 0x08; //‰ΩøÁî®ËÆ°Êï∞Âô®T2‰∏∫ËÆ°Êï∞Âô®Ê®°Âºè
                                  T2H=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
                                  T2L=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
                                  AUXR |= 0x10; //ËÆ°Êï∞Âô®2ÂºÄÂßãËÆ°Êï∞
                                  break;
                    case  LC_T3:                //‰ΩøÁî®ËÆ°Êï∞Âô®T3
                                  T4T3M |=0x04;//‰ΩøÁî®ËÆ°Êï∞Âô®T3‰∏∫ËÆ°Êï∞Âô®Ê®°Âºè
                                  T3H=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
                                  T3L=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
                                  AUXR |= 0x08; //ËÆ°Êï∞Âô®3ÂºÄÂßãËÆ°Êï∞
                                  break;
                    case  LC_T4:                //‰ΩøÁî®ËÆ°Êï∞Âô®T4
                                  T4T3M |=0x40; //‰ΩøÁî®ËÆ°Êï∞Âô®T3‰∏∫ËÆ°Êï∞Âô®Ê®°Âºè
                                  T4H=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
                                  T4L=0;        //ËÆ°Êï∞Âô®Ê∏ÖÈõ∂
                                  AUXR |= 0x80; //ËÆ°Êï∞Âô®4ÂºÄÂßãËÆ°Êï∞
                                  break;
              #endif
  83   2            default:
  84   2            
  85   2                return;       
  86   2         }  
  87   1        
  88   1        
  89   1        
  90   1        
  91   1        
  92   1      }
  93          //========================================================================
  94          // ÂáΩÊï∞: u8 BSP_GetGpioStatus(u8 pin)
  95          // ÊèèËø∞: ËØªÂèñËæìÂÖ•ÁÆ°ËÑöÁîµÂπ≥ÂÄº.Ê≠§ÂáΩÊï∞‰∏éÁ°¨‰ª∂ÁîµË∑ØÁõ∏ÂÖ≥ËÅî
  96          // ÂèÇÊï∞: ÊùøËΩΩËæìÂÖ•Âè£ÁºñÂè∑ÔºåÂèñÂÄºD1--D32.
  97          // ËøîÂõû: ËæìÂÖ•Âè£ÁîµÂπ≥ÂÄº.0ÊàñËÄÖ1
  98          // ÁâàÊú¨: V1.0, 2022-10-17
  99          //========================================================================
 100          u8 BSP_GetGpioStatus(u8 pin)//Êü•ËØ¢ÂØπÂ∫îÁöÑIOÂè£Áä∂ÊÄÅ
 101          {
 102   1        switch(pin)
 103   1        {
 104   2      #ifdef  STC12C5A60S2  
 105   2          case D1:    return(P00);
 106   2          case D2:    return(P01);
 107   2          case D3:    return(P02);
 108   2          case D4:    return(P03);
 109   2          case D5:    return(P04);
 110   2          case D6:    return(P05);
 111   2          case D7:    return(P06);
 112   2          case D8:    return(P07);
 113   2          case D9:    return(P27);
 114   2          case D10:   return(P26);
 115   2          case D11:   return(P25);
C51 COMPILER V9.60.0.0   BSP_GPIO                                                          09/20/2025 15:17:34 PAGE 3   

 116   2          case D12:   return(P24);
 117   2          case D13:   return(P23);
 118   2          case D14:   return(P22);
 119   2          case D15:   return(P21);
 120   2          case D16:   return(P20);
 121   2          case D17:   return(P10);
 122   2          case D18:   return(P11);
 123   2          case D19:   return(P12);
 124   2          case D20:   return(P13);
 125   2          case D21:   return(P14);
 126   2          case D22:   return(P15);
 127   2          case D23:   return(P16);
 128   2          case D24:   return(P17);
 129   2          case D25:   return(P32);
 130   2          case D26:   return(P33);
 131   2          case D27:   return(P34);
 132   2          case D28:   return(P35);
 133   2          case D29:   return(P36);
 134   2          case D30:   return(P37); 
 135   2          case D31:   return(P47);
 136   2          case D32:   return(P46);
 137   2          case D33:   return(P45);
 138   2          case D34:   return(P44); 
 139   2          case D35:   return(P44);
 140   2      #endif
 141   2      #ifdef  STC15W4K48S4  
                  case D1:    return(P45);
                  case D2:    return(P27);
                  case D3:    return(P02);
                  case D4:    return(P26);
                  case D5:    return(P03);
                  case D6:    return(P25);
                  case D7:    return(P04);
                  case D8:    return(P24);
                  case D9:    return(P05);
                  case D10:   return(P23);
                  case D11:   return(P06);
                  case D12:   return(P22);
                  case D13:   return(P07);
                  case D14:   return(P21);
                  case D15:   return(P20);
                  case D16:   return(P44);
                  case D17:   return(P12);
                  case D18:   return(P42);
                  case D19:   return(P13);
                  case D20:   return(P41);
                  case D21:   return(P14);
                  case D22:   return(P37);
                  case D23:   return(P15);
                  case D24:   return(P36);
                  case D25:   return(P35);
                  case D26:   return(P34);
                  case D27:   return(P33);
                  case D28:   return(P32);
                  case D29:   return(P54);
                  case D30:   return(P55); 
                  case D31:   return(P55);
                  case D32:   return(P55);
              #endif
 175   2      
 176   2          default: 
 177   2                      return(1);//ËøîÂõû1Â∞±ÊòØÊ≤°Êúâ‰ø°Âè∑
C51 COMPILER V9.60.0.0   BSP_GPIO                                                          09/20/2025 15:17:34 PAGE 4   

 178   2        }
 179   1      }
 180          //========================================================================
 181          // ÂáΩÊï∞: u8 BSP_ReadInputDataBit(SignalTypeDef *pSignal)
 182          // ÊèèËø∞: ËØªÂèñËæìÂÖ•ÁÆ°ËÑöÁîµÂπ≥ÂÄº.
 183          // ÂèÇÊï∞: SignalTypeDef‰∏∫ÊåáÂêë‰ø°Âè∑ÁªìÊûÑ‰ΩìÁöÑÊåáÈíà.
 184          // ËøîÂõû: ËøîÂõûTUREÔºåÊàñFALSE.
 185          // ÁâàÊú¨: V1.0, 2022-10-17
 186          //========================================================================
 187          u8 BSP_ReadInputDataBit(SignalTypeDef *pSignal)
 188          {
 189   1        xdata u8 status = 0;
 190   1        xdata u8 signalstatus = BSP_GetGpioStatus(pSignal->pin);//Ëé∑ÂèñÂçïÁâáÊú∫ÁöÑÁÆ°ËÑöËæìÂÖ•Áä∂ÊÄÅ
 191   1        
 192   1        if(pSignal->pin >= 64) //Â¶ÇÊûúÁÆ°ËÑöÊï∞ÂÄºË∂ÖËøá64ÔºåÁõ¥Êé•ËøîÂõû0
 193   1        {
 194   2            return FALSE;
 195   2        }
 196   1        if(pSignal->falling_ed == 255)  pSignal->falling_ed = 0;//Ê≠§Â§Ñ‰ªÖ‰∏∫ÂÖºÂÆπËÄÅÁâàÊú¨ÁöÑÁ®ãÂ∫èÔºåÊú™Â¢ûÂä
             -†ËØ•ÂèÇÊï∞ÁöÑÊÉÖÂÜµ
 197   1      
 198   1        if(pSignal->stateflag == 0)
 199   1        {
 200   2          if (signalstatus == pSignal->modle)//Âà§Êñ≠‰ø°Âè∑ÊòØÂê¶ÂºÄÂêØ
 201   2          {
 202   3            pSignal->times = 0;
 203   3            status = TURE;  
 204   3          }
 205   2          else if(pSignal->times < pSignal->rising_ed) //‰ø°Âè∑ÊäñÂä®‰∏éÂª∂Êó∂Â§ÑÁêÜ
 206   2          {
 207   3            (pSignal->times)++;
 208   3            status = TURE;  
 209   3          } 
 210   2          else 
 211   2          {
 212   3            pSignal->stateflag = 1;
 213   3            status = FALSE; 
 214   3          }
 215   2        }
 216   1        else 
 217   1        {
 218   2          if (signalstatus != pSignal->modle)//Ëé∑ÂèñÁõ∏Â∫îÁöÑÁä∂ÊÄÅ
 219   2          {
 220   3            pSignal->times = 0;
 221   3            status = FALSE;
 222   3          }
 223   2          else if(pSignal->times < pSignal->falling_ed) //‰ø°Âè∑ÊäñÂä®‰∏éÂª∂Êó∂Â§ÑÁêÜ
 224   2          {
 225   3            (pSignal->times)++;
 226   3            status = FALSE;
 227   3          } 
 228   2          else 
 229   2          {
 230   3            pSignal->stateflag = 0;
 231   3            status = TURE; 
 232   3          }   
 233   2        }
 234   1        #ifdef DEBUG1
                if(pSignal->pin ==12)
                {
                        printf("pin = %b02u  modle  = %b02u  times = %b02u rising_ed = %b02u falling_ed = %b02u\r\n"\
                              ,pSignal->pin,pSignal->modle,pSignal->times,pSignal->rising_ed,pSignal->falling_ed);
C51 COMPILER V9.60.0.0   BSP_GPIO                                                          09/20/2025 15:17:34 PAGE 5   

                        printf("gpiovalue = %b02d.  ",signalstatus);
                        printf("output = %b02d.\r\n",status);
                }
                #endif  
 243   1        return(status);
 244   1      }
 245          //========================================================================
 246          // ÂáΩÊï∞:BSP_ReadMultipleDataBit(MultSignalTypeDef *pSignal,u8 offset)
 247          // ÊèèËø∞: ËØªÂèñ‰∏Ä‰∏™‰º†ÊÑüÂô®Â§ö‰∏™‰ø°Âè∑Á∫ø
 248          // ÂèÇÊï∞: MultSignalTypeDefÊåáÂêëÂú∞ÂùÄÔºåpinËØªÁöÑÊòØÂì™‰∏ÄÊ†π‰ø°Âè∑Á∫ø.
 249          // ËøîÂõû: ËøîÂõûTUREÔºåÊàñFALSE.
 250          // ÁâàÊú¨: V1.0, 2022-10-17
 251          //========================================================================
 252          u8 BSP_ReadMultipleDataBit(MultSignalTypeDef *pSignal,u8 offset)
 253          {
 254   1          
 255   1        xdata u8 pin = *(u8 *)((u8 *)pSignal + offset  - 1);
 256   1        xdata u8 status = 0;
 257   1        xdata u8 signalstatus = BSP_GetGpioStatus(pin);//Ëé∑ÂèñÂçïÁâáÊú∫ÁöÑÁÆ°ËÑöËæìÂÖ•Áä∂ÊÄÅ
 258   1        xdata u8 flag = 0;//‰ø°Âè∑ÂèçËΩ¨Ê†áÂøó
 259   1        
 260   1        if(pin >= 64) //Â¶ÇÊûúÁÆ°ËÑöÊï∞ÂÄºË∂ÖËøá64ÔºåÁõ¥Êé•ËøîÂõû0
 261   1        {
 262   2            return FALSE;
 263   2        }
 264   1        flag = (((pSignal->stateflag) >> (offset-1)) & (0x01));//ÂæóÂà∞Ê†áÂøóÁä∂ÊÄÅ
 265   1        
 266   1        pSignal->times = pSignal->counts[offset-1];//Ëé∑ÂèñÂª∂Êó∂ËÆ°Êï∞Âô®ÁöÑÂÄº
 267   1        
 268   1        if(pSignal->falling_ed == 255)  pSignal->falling_ed = 0;//Ê≠§Â§Ñ‰ªÖ‰∏∫ÂÖºÂÆπËÄÅÁâàÊú¨ÁöÑÁ®ãÂ∫èÔºåÊú™Â¢ûÂä
             -†ËØ•ÂèÇÊï∞ÁöÑÊÉÖÂÜµ
 269   1          
 270   1        if(flag == 0)
 271   1        {
 272   2          if (signalstatus == pSignal->modle)//Âà§Êñ≠‰ø°Âè∑ÊòØÂê¶ÂºÄÂêØ
 273   2          {
 274   3            pSignal->times = 0;
 275   3            status = TURE;
 276   3          }
 277   2          else if(pSignal->times < pSignal->rising_ed) //‰ø°Âè∑ÊäñÂä®‰∏éÂª∂Êó∂Â§ÑÁêÜ
 278   2          {
 279   3            pSignal->times++;
 280   3            status = TURE;
 281   3          } 
 282   2          else 
 283   2          {
 284   3            flag = 1;
 285   3            status = FALSE; 
 286   3          }
 287   2        }
 288   1        else 
 289   1        {
 290   2          if (signalstatus != pSignal->modle)//Ëé∑ÂèñÁõ∏Â∫îÁöÑÁä∂ÊÄÅ
 291   2          {
 292   3            pSignal->times = 0;
 293   3            status = FALSE;
 294   3          }
 295   2          else if(pSignal->times < pSignal->falling_ed) //‰ø°Âè∑ÊäñÂä®‰∏éÂª∂Êó∂Â§ÑÁêÜ
 296   2          {
 297   3            pSignal->times++;
 298   3            status = FALSE;
 299   3          } 
C51 COMPILER V9.60.0.0   BSP_GPIO                                                          09/20/2025 15:17:34 PAGE 6   

 300   2          else 
 301   2          {
 302   3            flag = 0;
 303   3            status = TURE; 
 304   3          }   
 305   2        }
 306   1        pSignal->counts[offset-1]=pSignal->times;//‰øùÂ≠òÊú¨Ê¨°Âª∂Êó∂ËÆ°Êï∞Âô®ÁöÑÂÄº
 307   1        
 308   1        pSignal->stateflag |= (flag << offset-1);
 309   1          
 310   1        return(status);
 311   1        
 312   1      }
 313          
 314          
 315          ////========================================================================
 316          //// ÂáΩÊï∞:BSP_MultipdelayOutput(MultSignalTypeDef *pSignal,u8 value)
 317          //// ÊèèËø∞: Â§öË∑Ø‰ø°Âè∑ÁöÑÂª∂Êó∂ËæìÂá∫
 318          //// ÂèÇÊï∞: MultSignalTypeDefÊåáÂêëÂú∞ÂùÄÔºåvalueÂΩìÂâçÁöÑÂÄº.
 319          //// ËøîÂõû: ËøîÂõûTUREÔºåÊàñFALSE.
 320          //// ÁâàÊú¨: V1.0, 2023-8-31
 321          ////========================================================================
 322          //u8 BSP_delayOutput(u8 *times, u8 *counts, u8 *value)
 323          //{
 324          //  static  u8 state = 0;
 325          //  static  u8 times = 0;
 326          //  
 327          //  if(state != value) //ÂÄºÂèëÁîüÂèòÂåñ
 328          //  {
 329          //    
 330          //    if(times <  counts) //‰ΩøÁî®‰∏äÂçáÊ≤øÁöÑÂª∂Êó∂ÂèÇÊï∞
 331          //    {
 332          //      times++;
 333          //      
 334          //    }
 335          //    else 
 336          //    {
 337          //      times = 0;
 338          //      
 339          //      state = value;
 340          //      
 341          //    }
 342          //          
 343          //  }
 344          //  else 
 345          //  {
 346          //     times = 0;
 347          //  }
 348          //  
 349          //    printf("times = %b02u state = %b02u\r\n",times,state);
 350          //  
 351          //  return state;
 352          //  
 353          //  
 354          //}
 355          #ifdef  STC15W4K48S4  
              //========================================================================
              // ÂáΩÊï∞:BSP_ReadBumpDataBit(SignalTypeDef *pSignal,u8 group,u8 valuebit,u8 offset)
              // ÊèèËø∞: Á¢∞ÊùÜ‰º†ÊÑüÂô®Ê∂àÊäñ
              // ÂèÇÊï∞: MultSignalTypeDefÊåáÂêëÂú∞ÂùÄÔºåu8 Á¢∞ÊùÜÁä∂ÊÄÅÁöÑvalueÂÄº offsetËØªÁöÑÊòØÂì™‰∏ÄÊ†π‰ø°Âè∑Á∫øÔºà
             -‰ªé0ÂºÄÂßãÔºâ.
              // ËøîÂõû: ËøîÂõûTUREÔºåÊàñFALSE.
C51 COMPILER V9.60.0.0   BSP_GPIO                                                          09/20/2025 15:17:34 PAGE 7   

              // ÁâàÊú¨: V1.0, 2022-10-17
              //========================================================================
              u8 BSP_ReadBumpDataBit(SignalTypeDef *pSignal,u8 group,u8 valuebit,u8 offset)
              {
                xdata u8 status = 0;
                xdata u8 signalstatus = valuebit;//Ëé∑ÂèñËæìÂÖ•Áä∂ÊÄÅ
                
                xdata u8 flag = 0;//‰ø°Âè∑ÂèçËΩ¨Ê†áÂøó
                
                flag = (((pgxd[group].stateflag) >> offset) & (0x01));//ÂæóÂà∞Ê†áÂøóÁä∂ÊÄÅ
                
                pSignal->times = pgxd[group].times[offset];//Ëé∑ÂèñÂª∂Êó∂ËÆ°Êï∞Âô®ÁöÑÂÄº
                
                if(pSignal->falling_ed == 255)  pSignal->falling_ed = 0;//Ê≠§Â§Ñ‰ªÖ‰∏∫ÂÖºÂÆπËÄÅÁâàÊú¨ÁöÑÁ®ãÂ∫èÔºåÊú™Â¢ûÂä
             -†ËØ•ÂèÇÊï∞ÁöÑÊÉÖÂÜµ
                  
                if(flag == 0)
                {
                  if (signalstatus == TURE)//Âà§Êñ≠‰ø°Âè∑ÊòØÂê¶ÂºÄÂêØ
                  {
                    pSignal->times = 0;
                    status = TURE;
                  }
                  else if(pSignal->times < pSignal->rising_ed) //‰ø°Âè∑ÊäñÂä®‰∏éÂª∂Êó∂Â§ÑÁêÜ
                  {
                    pSignal->times++;
                    status = TURE;
                  } 
                  else 
                  {
                    flag = 1;
                    status = FALSE; 
                  }
                }
                else 
                {
                  if (signalstatus != TURE)//Ëé∑ÂèñÁõ∏Â∫îÁöÑÁä∂ÊÄÅ
                  {
                    pSignal->times = 0;
                    status = FALSE;
                  }
                  else if(pSignal->times < pSignal->falling_ed) //‰ø°Âè∑ÊäñÂä®‰∏éÂª∂Êó∂Â§ÑÁêÜ
                  {
                    pSignal->times++;
                    status = FALSE;
                  } 
                  else 
                  {
                    flag = 0;
                    status = TURE; 
                  }   
                }
                #ifdef DEBUG1
                  if(pin == 13)
                  {
                  printf("pin = %b02u  modle  = %b02u  times = %b02u rising_ed = %b02u falling_ed = %b02u\r\n"\
                              ,pin,pSignal->modle,pSignal->times,pSignal->rising_ed,pSignal->falling_ed);
                  printf("gpiovalue = %b02d.  ",signalstatus);
                  printf("output = %b02d.\r\n",status);
                  }
                
                #endif  
C51 COMPILER V9.60.0.0   BSP_GPIO                                                          09/20/2025 15:17:34 PAGE 8   

                  
                pgxd[group].times[offset] = pSignal->times;//‰øùÂ≠òÊú¨Ê¨°Âª∂Êó∂ËÆ°Êï∞Âô®ÁöÑÂÄº
                
                if( flag == 0 )
                {
                  pgxd[group].stateflag &= ~(u16)(1<< offset);//Êõ¥Êñ∞Ê∂àÊäñÂ§ÑÁêÜÁªìÊûú
                }
                else 
                  pgxd[group].stateflag |= (u16)(1<< offset);//Êõ¥Êñ∞Ê∂àÊäñÂ§ÑÁêÜÁªìÊûú
                
                return(status);
              }
              #endif
 435          
 436          
 437          
 438          
 439          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    952    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
