C51 COMPILER V9.60.0.0   BSP_USART                                                         09/20/2025 15:17:35 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE BSP_USART
OBJECT MODULE PLACED IN .\Objects\bsp_usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Bsp\bsp_usart.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(
                    -.\Listings\bsp_usart.lst) TABS(2) OBJECT(.\Objects\bsp_usart.obj)

line level    source

   1          #include "./User/includes.h"
   2          #include <stdio.h>
   3          #include <string.h>
   4          
   5          
   6            
   7          #ifdef  STC12C5A60S2  
   8            xdata UsartRxTypeDef Rx[2]; 
   9            xdata u8 Rx1_Buffer[COM_Rx_LENTH];
  10            xdata u8 Rx2_Buffer[COM_Rx_LENTH];
  11          #endif
  12          
  13          
  14          #ifdef  STC15W4K48S4  
                xdata UsartRxTypeDef Rx[4]; 
                xdata u8 Rx1_Buffer[GPS_Rx_LENTH];
                xdata u8 Rx2_Buffer[COM_Rx_LENTH];
                xdata u8 Rx3_Buffer[COM_Rx_LENTH];
                xdata u8 Rx4_Buffer[COM_Rx_LENTH];
                  
              #endif
  22          //========================================================================
  23          // å‡½æ•°:char putchar(char ch) printfé‡å®šå‘å‡½æ•°
  24          // æè¿°:printfé‡å®šå‘åˆ°usart1
  25          // å‚æ•°ï¼š
  26          // ç‰ˆæœ¬: 
  27          //========================================================================
  28          char putchar(char ch)  //å‡½æ•°é»˜è®¤çš„ï¼Œåœ¨ä½¿ç”¨printfå‡½æ•°æ—¶è‡ªåŠ¨è°ƒç”¨
  29          {
  30   1        #ifdef  STC15W4K48S4
                  USART_SendData(NETWORK_USART,(char)ch);
                #endif
  33   1        
  34   1        #ifdef  STC12C5A60S2  
  35   1          USART_SendData(CONSOLE_USART,(char)ch);
  36   1        #endif
  37   1        return ch;
  38   1      }
  39          //========================================================================
  40          // å‡½æ•°:BSP_Usart_Init(unsigned char USARTx,unsigned long bote)
  41          // æè¿°: åˆå§‹åŒ–ä¸²å£
  42          // å‚æ•°ï¼šUSARTxç«¯å£å·ï¼Œboteæ³¢ç‰¹ç‡
  43          // ç‰ˆæœ¬: V1.0, 2022-10-17
  44          //========================================================================
  45          void BSP_Usart_Init(unsigned char USARTx,unsigned long bote)
  46          {
  47   1        COMx_InitDefine   COMx_InitStructure;                 //ç»“æ„å®šä¹‰
  48   1        
  49   1        if(USARTx == USART1)
  50   1        { 
  51   2          Rx[USARTx-1].pStart = Rx1_Buffer;
  52   2          Rx[USARTx-1].pEnd  = (u8 *)(Rx1_Buffer + sizeof(Rx1_Buffer) -1);
  53   2          Rx[USARTx-1].pIn   = Rx[USARTx-1].pStart;
  54   2          Rx[USARTx-1].overflow_flag = 0;
C51 COMPILER V9.60.0.0   BSP_USART                                                         09/20/2025 15:17:35 PAGE 2   

  55   2          memset(Rx1_Buffer,0,sizeof(Rx1_Buffer));
  56   2          
  57   2          COMx_InitStructure.UART_BRT_Use   = BRT_Timer1;       //ä½¿ç”¨æ³¢ç‰¹ç‡å‘ç”Ÿå™¨,   BRT_Timer1, BRT_Timer2
             - 
  58   2        }
  59   1        else if(USARTx == USART2)
  60   1        {
  61   2          Rx[USARTx-1].pStart = Rx2_Buffer;
  62   2          Rx[USARTx-1].pEnd  = Rx2_Buffer + sizeof(Rx2_Buffer) -1;
  63   2          Rx[USARTx-1].pIn   = Rx[USARTx-1].pStart;
  64   2          Rx[USARTx-1].overflow_flag = 0;
  65   2          memset(Rx2_Buffer,0,sizeof(Rx2_Buffer));
  66   2          
  67   2          COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;       //ä½¿ç”¨æ³¢ç‰¹ç‡å‘ç”Ÿå™¨,   BRT_Timer2 (æ³¨æ„: ä¸
             -²å£2å›ºå®šä½¿ç”¨BRT_Timer2)
  68   2        }
  69   1      #ifdef  STC15W4K48S4  
                else if(USARTx == USART3)
                {
                  Rx[USARTx-1].pStart = Rx3_Buffer;
                  Rx[USARTx-1].pEnd  = Rx3_Buffer + sizeof(Rx3_Buffer) -1;
                  Rx[USARTx-1].pIn   = Rx[USARTx-1].pStart;
                  Rx[USARTx-1].overflow_flag = 0;
                  memset(Rx3_Buffer,0,sizeof(Rx3_Buffer));
                  
                  COMx_InitStructure.UART_BRT_Use   = BRT_Timer3;       //ä½¿ç”¨æ³¢ç‰¹ç‡å‘ç”Ÿå™¨,   BRT_Timer2, BRT_Timer3
             - 
                }
                else if(USARTx == USART4)
                {
                  Rx[USARTx-1].pStart = Rx4_Buffer;
                  Rx[USARTx-1].pEnd  = Rx4_Buffer + sizeof(Rx4_Buffer) -1;
                  Rx[USARTx-1].pIn   = Rx[USARTx-1].pStart;
                  Rx[USARTx-1].overflow_flag = 0;
                  memset(Rx4_Buffer,0,sizeof(Rx4_Buffer));
                  
                  COMx_InitStructure.UART_BRT_Use   = BRT_Timer4;       //ä½¿ç”¨æ³¢ç‰¹ç‡å‘ç”Ÿå™¨,   BRT_Timer2, BRT_Timer4
             - 
                }
              #endif
  91   1        else 
  92   1        {
  93   2          return;
  94   2        }
  95   1        if(bote == DISABLE)  return;                          //æ£€æŸ¥æ³¢ç‰¹ç‡ï¼Œä¸ºDISABLEæ—¶ï¼Œä¸åˆå§‹åŒ–è¯¥ä¸²å£
  96   1        COMx_InitStructure.UART_BaudRate  = bote;             //æ³¢ç‰¹ç‡, ä¸€èˆ¬ 110 ~ 115200
  97   1        COMx_InitStructure.UART_Interrupt = ENABLE;           //ä¸­æ–­å…è®¸,   ENABLEæˆ–DISABLE
  98   1        USART_Configuration(USARTx, &COMx_InitStructure);     //åˆå§‹åŒ–ä¸²å£1 USART1,USART2
  99   1      }
 100          //========================================================================
 101          // å‡½æ•°:u16 BSP_GetUsartRxBuffer(u8 USARTx,u8 *RxBuffer,u16 *lenth)
 102          // æè¿°: è¯»å–ä¸²å£ç¼“å­˜ä¸­çš„æ•°æ®ï¼Œç»­å†™ï¼Œå¦‚åè®®åŒ¹é…æˆåŠŸï¼Œlenthéœ€è½¯ä»¶æ¸…é›¶
 103          // å‚æ•°ï¼šu8 USARTxä¸ºç«¯å£å·ï¼ŒRxBufferç¼“å­˜åŒºæŒ‡é’ˆ,ç¼“å­˜åŒºçš„é•¿åº¦
 104          // è¿”å›ï¼šè¯»å–çš„æ•°æ®é•¿åº¦
 105          // ç‰ˆæœ¬: V1.0, 2022-10-17
 106          //========================================================================
 107          u16 BSP_GetUsartRxBuffer(u8 USARTx,u8 *pRxBuffer,u16 Rxlenth)
 108          {
 109   1        xdata u16 remaindlen = 0;   //æ•°ç»„å‰©ä½™ç©ºé—´å¤§å°ï¼Œæ£€éªŒæº¢å‡ºæ—¶ä½¿ç”¨
 110   1        xdata u16 lenth = 0;        //ç¼“å­˜å»æ•°æ®é•¿åº¦
 111   1        xdata u16 i = 0;
 112   1        
C51 COMPILER V9.60.0.0   BSP_USART                                                         09/20/2025 15:17:35 PAGE 3   

 113   1        
 114   1        if((USARTx == DISABLE) || (USARTx >= USARTMAX)) //ç¡¬ä»¶ä¸²å£æœªåˆå§‹åŒ–
 115   1        { 
 116   2          return 0;//è¿”å›0
 117   2        }
 118   1        //printf("BSP_GetUsartRxBuffer:USARTx = %b02d\r\n",USARTx);
 119   1        
 120   1        remaindlen = (u16)(Rx[USARTx-1].pEnd - Rx[USARTx-1].pIn) + 1;//è®¡ç®—å‰©ä½™ç©ºé—´å¤§å°
 121   1        
 122   1        lenth = USART_ReadRxBuffer(USARTx,Rx[USARTx-1].pIn,remaindlen);//è¯»å–ä¸²å£æ¥æ”¶çš„ç¼“å­˜æ•°æ®
 123   1        
 124   1        Rx[USARTx-1].pIn = (u8 *)(Rx[USARTx-1].pIn + lenth);//å°†æŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸€æ¬¡éœ€è¦å†™å…¥æ•°æ®çš„ä½
             -ç½®
 125   1        
 126   1        lenth = (u16)(Rx[USARTx-1].pIn - Rx[USARTx-1].pStart); //æ•°æ®é•¿åº¦æ¥ç»­
 127   1        
 128   1        if(Rx[USARTx-1].pIn >= Rx[USARTx-1].pEnd) //æ£€æŸ¥æ•°ç»„æ˜¯å¦è¶Šç•Œ
 129   1        {
 130   2        
 131   2          BSP_ClearUsartRxBuffer(USARTx);//è½¯ä»¶è‡ªåŠ¨æ¸…ç©ºç¼“å­˜åŒºåŸŸ
 132   2      
 133   2          printf("BSP_GetUsartRxBuffer:Index overflow!!!  USARTx = %b02d\r\n",USARTx);
 134   2          
 135   2          #ifdef DEBUG
                  printf("BSP_GetUsartRxBuffer:Index overflow!!!  USARTx = %b02d\r\n",USARTx);  
                  #endif  
 138   2          
 139   2          lenth = 0;//è½¯ä»¶è‡ªåŠ¨æ¸…ç©ºç¼“å­˜åŒºåŸŸ
 140   2        }
 141   1      
 142   1        if(lenth >= Rxlenth)//æ•°æ®å†…å®¹è¶…è¿‡äº†éœ€è¦å†™çš„ç¼“å­˜ç©ºé—´äº†
 143   1        {
 144   2          lenth = Rxlenth;  //æˆªæ–­æ•°æ®
 145   2          
 146   2          printf("Rxlenth:Index overflow!!!  USARTx = %b02d\r\n",USARTx);
 147   2          
 148   2          for (i = 0;i < Rxlenth; i++) //æ•°æ®æ‹·è´
 149   2          {
 150   3            *pRxBuffer++ = *(Rx[USARTx-1].pStart+i);  
 151   3          }
 152   2          BSP_ClearUsartRxBuffer(USARTx);//è½¯ä»¶è‡ªåŠ¨æ¸…ç©ºç¼“å­˜åŒºåŸŸ
 153   2        }
 154   1        else
 155   1        {
 156   2          for (i = 0;i < lenth; i++) //æ•°æ®æ‹·è´
 157   2          {
 158   3            *pRxBuffer++ = *(Rx[USARTx-1].pStart+i);  
 159   3          }
 160   2          
 161   2        }
 162   1        
 163   1        *pRxBuffer = '\0';         //ä»…ç”¨äºåç»­å­—ç¬¦ä¸²å¤„ç†æ—¶ä½œä¸ºç»“æŸç¬¦å·ä½¿ç”¨
 164   1        
 165   1        return lenth;
 166   1        
 167   1      }
 168          #ifdef  STC15W4K48S4
              //========================================================================
              // å‡½æ•°:u16 BSP_GetFormatRxBuffer(u8 USARTx,u8 *RxBuffer,u16 *lenth,u8 *cutstr)
              // æè¿°: è·å–ä¸²å£ç¼“å­˜ä¸­çš„æ•°æ®ï¼ŒæŒ‰ç…§cutstrè¿›è¡Œåˆ‡å‰²è¯»å–.
              // å‚æ•°ï¼šu8 USARTxä¸ºç«¯å£å·ï¼ŒRxBufferç¼“å­˜åŒºæŒ‡é’ˆ,Rxlenthç¼“å­˜åŒºçš„é•¿åº¦,u8 ä»¥*cutsträ½œä¸ºå
             -ˆ‡å‰²å­—ç¬¦ä¸² cutlenth,æ˜¯åˆ‡å‰²å­—ç¬¦çš„é•¿åº¦
C51 COMPILER V9.60.0.0   BSP_USART                                                         09/20/2025 15:17:35 PAGE 4   

              // è¿”å›ï¼šè¯»å–çš„æ•°æ®é•¿åº¦
              // ç‰ˆæœ¬: V1.0, 2022-10-17
              //========================================================================
              u16 BSP_GetFormatRxBuffer(u8 USARTx,u8 *pRxBuffer,u16 Rxlenth,u8 *cutstr,u8 cutlenth)
              {
                xdata u16 lenth = 0;          //ç¼“å­˜æ•°æ®é•¿åº¦
                xdata u8  *pTemp     = NULL;
                xdata u8  *pStart    = NULL;
                xdata u8  *pcutstr    = NULL;
                xdata u8  i  = 0;
              
                
                if((USARTx == DISABLE) || (USARTx >= USARTMAX)) //ç¡¬ä»¶ä¸²å£æœªåˆå§‹åŒ–
                { 
                  return 0;//è¿”å›0
                }
                
                lenth = BSP_GetUsartRxBuffer(USARTx,pRxBuffer,Rxlenth);//è¯»å–ç¼“å­˜æ•°æ®
                
                pcutstr = ByteArrayCompar_r(pRxBuffer,lenth,cutstr,cutlenth);//æ‰¾åˆ°åˆ‡å‰²å­—ç¬¦ä¸²çš„ä½ç½®ï¼Œä»åå¾€
             -å‰æ‰¾ã€‚
                
                if(pcutstr == NULL)//æœªæŸ¥è¯¢åˆ°åˆ‡å‰²å­—ç¬¦
                {
                  memset(pRxBuffer,0,Rxlenth);//æ¸…ç©ºç¼“å­˜æ•°æ®
                  
                  //printf("BSP_GetFormatRxBuffer lenth = %h04d\r\n",lenth);
                  
                  lenth = 0;//è¯»å–é•¿åº¦ä¸º0
                  
                  
                  return lenth;//è¿”å›0
                }
                //å¤„ç†ç¼“å­˜åŒºpRxBufferçš„æ•°æ®
                if(*(cutstr+cutlenth-1) == '\n')//å¦‚æœæœ‰æ¢è¡Œç¬¦å¹¶ä¸”æ˜¯æœ«å°¾åˆ‡åˆ†
                {
                  //printf("BSP_GetFormatRxBuffer lenth = %h04d\r\n",lenth);
                  
                  pcutstr = (u8 *)(pcutstr +1);//è·³è¿‡åˆ‡å‰²å­—ç¬¦
                  
                }
                lenth = (u16)(pcutstr - pRxBuffer);//æ•°æ®é•¿åº¦ï¼Œè¿”å›ç»™è°ƒç”¨è€…
                
                memset(pcutstr,0,(u16)(Rxlenth - lenth));//æ¸…é™¤å¤šä½™çš„æ•°æ®ï¼Œè¿”å›ç»™è°ƒç”¨è€…
                
                //å¤„ç†ç¼“å­˜åŒºRxçš„æ•°æ®
                pStart = Rx[USARTx-1].pStart;
                
                pTemp = (u8 *)(pStart + lenth);
                
                while (pTemp  < Rx[USARTx-1].pIn)
                {
                    *pStart++ = *pTemp++;    //å°†å‰©ä¸‹çš„æ•°æ®ç§»åˆ°ç¼“å­˜åŒºçš„é¦–åœ°å€  
                }
                memset(pStart,0,(u16)(Rx[USARTx-1].pEnd - pStart +1));//æ¸…é™¤åç»­ç¼“å­˜
                
                Rx[USARTx-1].pIn = pStart;
                
                return lenth;
              }
              #endif
 233          //========================================================================
C51 COMPILER V9.60.0.0   BSP_USART                                                         09/20/2025 15:17:35 PAGE 5   

 234          // å‡½æ•°:void BSP_ClearUsartRxBuffer(u8 USARTx)
 235          // æè¿°: æ¸…ç†ä¸²å£ç¼“å­˜æ•°æ®
 236          // å‚æ•°ï¼šu8 USARTxä¸ºç«¯å£å·
 237          // ç‰ˆæœ¬: V1.0, 2022-10-17
 238          //========================================================================
 239          void BSP_ClearUsartRxBuffer(u8 USARTx)
 240          {
 241   1        xdata u16 lenth = 0;
 242   1      
 243   1        if((USARTx == DISABLE) || (USARTx >= USARTMAX))  return;//ç¡¬ä»¶ä¸²å£æœªå¼€å¯
 244   1        
 245   1        lenth = (u16)(Rx[USARTx-1].pEnd - Rx[USARTx-1].pStart + 1);//è®¡ç®—ç¼“å­˜åŒºçš„æ€»é•¿åº¦
 246   1        
 247   1        memset(Rx[USARTx-1].pStart, 0,lenth);//ç¼“å­˜åŒºæ¸…é›¶
 248   1        
 249   1        Rx[USARTx-1].pIn = Rx[USARTx-1].pStart;   //æŒ‡å‘ç¼“å­˜åŒºé¦–åœ°å€
 250   1        
 251   1         #ifdef DEBUG
                  printf("Rx[%b02d]Clear,OK!\r\n",(USARTx-1));
                 #endif
 254   1      }
 255          //========================================================================
 256          // å‡½æ•°:WaitForTISignal(u8 USARTx)
 257          // æè¿°: ç­‰å¾…ä¸²å£æ•°æ®å‘é€å®Œæˆï¼Œé˜»å¡æ¨¡å¼
 258          // å‚æ•°ï¼šu8 USARTxä¸²å£å·
 259          // ç‰ˆæœ¬: V1.0, 2022-10-17
 260          //========================================================================
 261          static void WaitForTISignal(u8 USARTx)
 262          {
 263   1        if(USARTx == USART1)
 264   1        {
 265   2          while(TI == 0); 
 266   2          TI = 0;
 267   2        }
 268   1        else if(USARTx == USART2)
 269   1        {
 270   2          while((S2CON & 2) == 0); 
 271   2          S2CON &= ~2;
 272   2        }
 273   1        #ifdef  STC15W4K48S4
                else if(USARTx == USART3)
                {
                  while(TI3 ==0);
                  CLR_TI3();
                }
                else if(USARTx == USART4)
                {
                  while(TI4==0);
                  CLR_TI4();   
                }
                #endif
 285   1        else 
 286   1        {
 287   2          return;
 288   2        }
 289   1      }
 290          //========================================================================
 291          // å‡½æ•°:void USART_SendData(u8 USARTx,u8 ch)
 292          // æè¿°: ä¸²å£æ•°æ®å‘é€æ¨¡å¼ï¼ŒæŸ¥è¯¢æ–¹å¼
 293          // å‚æ•°ï¼šu8 USARTxä¸²å£å·,u8 chéœ€è¦å‘é€çš„æ•°æ®
 294          // ç‰ˆæœ¬: V1.0, 2022-10-17
 295          //========================================================================
C51 COMPILER V9.60.0.0   BSP_USART                                                         09/20/2025 15:17:35 PAGE 6   

 296          void USART_SendData(u8 USARTx,u8 ch)
 297          {
 298   1        #ifdef  STC12C5A60S2
 299   1          P483 =1;//483å‘é€çŠ¶æ€
 300   1          delay50us();
 301   1        #endif
 302   1        if((USARTx == DISABLE) || (USARTx >= USARTMAX)) //ç¡¬ä»¶ä¸²å£æœªåˆå§‹åŒ–
 303   1        { 
 304   2          return ;//ç›´æ¥è¿”å›
 305   2        }
 306   1        switch(USARTx)
 307   1        {
 308   2          case USART1:
 309   2                      SBUF = ch;
 310   2                      break;
 311   2          case USART2:
 312   2                      S2BUF = ch;
 313   2                      break;
 314   2      #ifdef  STC15W4K48S4
                  case USART3:
                              S3BUF = ch;
                              break;    
                  case USART4:
                              S4BUF = ch;
                              break;  
              #endif
 322   2          default:
 323   2                      break;
 324   2          
 325   2        }
 326   1        WaitForTISignal(USARTx);//ç­‰å¾…æ•°æ®ä¼ è¾“å®Œæˆ
 327   1        #ifdef  STC12C5A60S2
 328   1          P483 =0;//483æ¥æ”¶çŠ¶æ€
 329   1          delay50us();
 330   1        #endif  
 331   1      }
 332          //========================================================================
 333          // å‡½æ•°:void USART_Sendbuffer(u8 USARTx,const u8 *ch, u16 lenth)
 334          // æè¿°: ä¸²å£æ•°æ®å‘é€æ¨¡å¼ï¼ŒæŸ¥è¯¢æ–¹å¼
 335          // å‚æ•°ï¼šu8 USARTxä¸²å£å·,u8 chéœ€è¦å‘é€çš„æ•°æ®,lenthç¼“å­˜åŒºçš„é•¿åº¦
 336          // ç‰ˆæœ¬: V1.0, 2022-10-17
 337          //========================================================================
 338          void USART_Sendbuffer(u8 USARTx,const u8 *ch, u16 lenth)
 339          {
 340   1        u16 i = 0;
 341   1        //printf("USART_Sendbuffer\r\n");
 342   1        for (i=0;i<lenth;i++)
 343   1        {
 344   2          USART_SendData(USARTx,*ch++);
 345   2        }
 346   1        
 347   1      }
 348          
 349          //========================================================================
 350          // å‡½æ•°:printf_buffer(const char *name,const u8 *pbuffer,u16 lenth)
 351          // æè¿°: æ ¼å¼åŒ–ç­”åº”æ•°ç»„å†…å®¹
 352          // å‚æ•°ï¼šnameä¸ºæ‰“å°å‡ºæ¥çš„æ•°ç»„åç§°,pbufferä¸ºæ•°ç»„åç§°ï¼Œlenthä¸ºæ‰“å°æ•°ç»„å‰å¤šå°‘ä¸ªå…
             -ƒç´ 
 353          // ç‰ˆæœ¬: V1.0, 2022-10-17
 354          //========================================================================
 355          #ifdef DEBUG1
              void printf_buffer(const char *name,const u8 *pbuffer,u16 lenth)
C51 COMPILER V9.60.0.0   BSP_USART                                                         09/20/2025 15:17:35 PAGE 7   

              {
                int i = 0;
                printf("%s:",name);
                for (i = 0; i < lenth; i++)
                {
                  printf("%b02X",*pbuffer++); 
                  printf(" ");      
                }
                printf("\r\n");
              }
              #endif
 368          //========================================================================
 369          // å‡½æ•°:HextoStr(const u8 *pbuffer,char *pStr,u16 lenth)
 370          // æè¿°: å°†å­—ç¬¦æ•°ç»„è½¬æ¢æˆå­—ç¬¦ä¸²ï¼Œ
 371          // å‚æ•°ï¼špbufferä¸ºå­—èŠ‚æ•°ç»„åç§°ï¼ŒpStréœ€è¦ä¿å­˜å­—ç¬¦ä¸²çš„åœ°å€ï¼Œlenthä¸ºå­—èŠ‚æ•°ç»„çš„é•¿
             -åº¦
 372          // ç‰ˆæœ¬: V1.0, 2022-10-17
 373          //========================================================================
 374          #ifdef  STC15W4K48S4  
              void HextoStr(const u8 *pbuffer,u8 *pStr,u16 lenth)
              {
                u16 i = 0;
                char temp[3] = "";
                
                xdata u8 num=0x2D;  //å­—å¤´â€œZBSJ,â€çš„ASCIIå¼‚æˆ–å€¼
                
                for (i = 0; i < lenth-1; i++) //æ ¼å¼åŒ–åˆ°æ ¡éªŒå’Œå‰ä¸€ä½
                {
                  sprintf(temp,"%b02X",*pbuffer++);
                  strcat(pStr,temp);
                  num^=temp[0];     //å¼‚æˆ–æ ¡éªŒ
                  num^=temp[1];
              
                }
                
                strcat(pStr,"*");           //æ ¡éªŒå’Œå®šç•Œç¬¦ã€‚ä¸ºæ•°æ®å†…å®¹å’Œæ ¡éªŒå’Œå­—æ®µçš„åˆ†éš”ç¬¦ã€‚
                sprintf(temp,"%b02X",num);  //æ ¼å¼åŒ–å¼‚æˆ–æ ¡éªŒå’Œ
                strcat(pStr,temp);          //è¿½åŠ æ ¡éªŒå’Œæ•°æ®
                strcat(pStr,"\r\n");        //ç»ˆæ­¢ç¬¦ï¼ˆASCII ç å­—ç¬¦ HEX0D0Aï¼‰ã€‚æ ‡å¿—ä¸€ä¸ªè¯­å¥çš„ç»“æŸã€‚
                
              /*
                æ ¡éªŒå’Œä¸ºè¯­å¥ä¸­â€œ$â€å’Œâ€œ*â€ä¹‹é—´(ä¸å«ç¬¦å·â€œ$â€å’Œâ€œ*â€)å…¨éƒ¨å­—ç¬¦æŒ‰å­—èŠ‚å¼‚æˆ–çš„
             -ç»“æœï¼Œ
              */
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1348    ----
   CONSTANT SIZE    =    101    ----
   XDATA SIZE       =     84      37
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
